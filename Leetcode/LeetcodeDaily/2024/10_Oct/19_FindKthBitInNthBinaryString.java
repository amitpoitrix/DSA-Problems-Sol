/*
 * 1545. Find Kth Bit in Nth Binary String
 * Link: https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/
 * 
 * 
 * Approach: 
 * 
 * Recursive Structure: The binary sequence at level n is built recursively by taking the sequence at level n-1, 
 * adding a '1', and then appending the reverse of n-1 where each bit is flipped. This pattern can be leveraged 
 * to recursively find the k-th bit.
 * 
 * Base Case: When n = 1, the sequence is just '0', so if the search reaches this level, the result is '0'.
 * 
 * Midpoint Check: The sequence length at level n is 2^n - 1. The midpoint is always '1'. If k is exactly at this 
 * midpoint, return '1'.
 * 
 * First Half: If k lies in the first half of the sequence, the answer can be found by recursively searching the 
 * corresponding position in the sequence for n-1.
 * 
 * Second Half: If k is in the second half, it corresponds to a mirrored and flipped bit of the first half. 
 * Recursively find the corresponding bit in the first half and flip it.
 * 
 * This approach efficiently uses recursion to handle the reverse and flip operations without generating the entire 
 * sequence explicitly.
 */

class Solution1 {
    public char findKthBit(int n, int k) {
        // Using Recursion

        // Step 1: Base Case
        if(n == 1)
            return '0';

        // Step 2: Now based on ceil(length) < k, == k & > k
        int len = (1 << n) - 1; // 2^n - 1

        if(k < (len / 2) + 1) {
            return findKthBit(n - 1, k);
        } else if(k == (len / 2) + 1) {
            return '1';
        } else {
            // ceil(len / 2) > k
            return findKthBit(n - 1, len - k + 1) == '0' ? '1': '0';
        }
    }
}


/**
 * Similar Questions:
 * 
 * 779. K-th Symbol in Grammar
 * https://leetcode.com/problems/k-th-symbol-in-grammar/description/
 * 
 * Explaination Diagram:
 * https://github.com/user-attachments/assets/484f99e7-2c4f-4f93-a5d8-27bd3eb392ad
 * 
 * Recursion Flow:
 * https://github.com/user-attachments/assets/eb0932ab-11cf-42d9-a4cb-17612893724f
 * 
 * 
 * Summary:
 * First draw diagram from n = 1 to 4 and observe the recursive calls needed.
 * 
 * Base Case: 
 * when n = 1 & k = 1 than we return 0
 * 
 * Recursive Case: 
 * We'll find the mid and if k <= mid than we'll call previous recursive call - solve(n - 1, k)
 * else we'll call previous recursive call with k as k - mid with ! (negation) - !solve(n - 1, k - mid)
 * 
 * Complexity:
 * Time: O(n)
 * Space: O(n)
 */

class Solution2 {
    public int kthGrammar(int n, int k) {
        // Base Case
        if(n == 1 && k == 1) {
            return 0;
        }

        // Recursive Case
        int length = (int)Math.pow(2, n - 1);
        int mid = length / 2;

        if(k <= mid) {
            return kthGrammar(n - 1, k);
        } else {
            return 1 - kthGrammar(n - 1, k - mid); // negation 1 -> 0 & 0 -> 1
        }
    }
}


/**
 * 3304. Find the K-th Character in String Game I
 * https://leetcode.com/problems/find-the-k-th-character-in-string-game-i/description/
 * 
 * Summary:
 * In this kind of problem where you've to find the kth character, first find the min length where k lies 
 * Than after getting value of length find using recursion.
 * 
 */
class Solution3 {
    public char kthCharacter(int k) {
        // Step 1: First find the min len of word needed to have atleast k characters
        int len = 1;    // intial word = 'a'
        while(len < k) {
            len *= 2;
        }

        return solve(len, k);
    }

    private char solve(int len, int k) {
        // Base Case
        if(k == 1) {
            return 'a';
        }
        
        // Recursive Case:
        if(k <= (len / 2)) {
            // 1st Half - no change to next character
            return solve(len / 2, k);
        } else {
            // 2nd Half - change to next character
            char ch = solve(len / 2, k - (len / 2));

            return ch == 'z' ? 'a': (char)(ch + 1);
        }
    }
}

// w = a
// w = a b 
// w = a b b c
// w = a b b c b c c d

 
 /**
 * 3307. Find the K-th Character in String Game II 
 * https://leetcode.com/problems/find-the-k-th-character-in-string-game-ii/description/
 * 
 * Explaination Diagram:
 * https://github.com/user-attachments/assets/a97dbb70-6ef3-4ecb-bb99-32056d4f8702
 * https://github.com/user-attachments/assets/26d6405c-2c4c-4f8a-8405-35a73a9a7d82
 * 
 * Summary:
 * The problem is to determine the k-th character in a sequence generated by a series of operations defined in the 
 * operations array. 
 * The approach involves recursively determining the character by considering the transformation operations applied at 
 * each step.
 * 
 * Identify the Length: 
 * Traverse through the operations array to calculate the cumulative length until it surpasses or equals k.
 * 
 * Adjust k Value: 
 * When the cumulative length is found, update k to a new value and retrieve the operation type.
 * 
 * Recursive Call: 
 * Recursively determine the k-th character before applying the identified operation.
 * 
 * Transformation Based on Operation Type: 
 * Apply the transformation defined by the operation type (0 means no change, 1 means increment the character).
 * 
 * 
 * Complexity:
 * Time: O(nlogn); 
 * After each step, the problem size is halved, meaning that we are essentially performing a logarithmic number of recursive 
 * calls & at each recursive call we're running over operations[] O(n) times.
 * 
 * Space: O(logn); 
 * The recursive function uses a divide-and-conquer approach, and the depth of recursion will be proportional to the number 
 * of operations, which is O(logn), since the string doubles in size with each operation.
 */

class Solution4 {
    public char kthCharacter(long k, int[] operations) {
        // Base Case: means what's the 1st character of any word
        if(k == 1) {
            return 'a';
        }

        // Recursive Case:
        // Step 1: First find the min length which is equal or greater than current k
        long len = 1;   // length of word 'a' is 1
        int operationsType = -1;
        
        for(int i = 0; i < operations.length; i++) {
            len *= 2;   // a aa aaaa aaaaaaaa

            if(len >= k) {
                operationsType = operations[i];
                break;
            }
        }
        
        // Step 2: Recursive call with updated value of k
        char ch = kthCharacter(k - (len / 2), operations);

        if(operationsType == 0) {
            // return same character
            return ch;
        } else {
            // return next character
            return ch == 'z' ? 'a': (char)(ch + 1);
        }
    }
}

// Consider operations as 0 
// a
// a a
// a a a a
// a a a a a a a a

// solve(k - l / 2);
