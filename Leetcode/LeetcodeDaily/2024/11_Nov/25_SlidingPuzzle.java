import java.util.*;

/*
 * 773. Sliding Puzzle
 * Link: https://leetcode.com/problems/sliding-puzzle/description/?envType=daily-question&envId=2024-11-25
 * 
 * 
 * Approach:
 * The solution uses Breadth-First Search (BFS) to solve the sliding puzzle problem. The idea is to treat each 
 * board configuration as a node in a graph and find the shortest path (minimum moves) from the initial board
 * state to the target state ("123450").
 * 
 * Steps:
 * Convert the board to a string: The initial board configuration is converted into a string to facilitate easy 
 * comparison and manipulation.
 * 
 * Adjacency list for valid moves: A predefined map stores the valid moves for the empty slot (0), representing 
 * adjacent positions where the 0 can slide.
 * 
 * Use BFS for exploration: A queue is used to perform BFS, starting from the initial configuration. Each level of
 * BFS corresponds to a single move.
 * 
 * Swap positions to generate new states: For each state, the adjacent configurations are generated by swapping 0 
 * with its neighboring positions.
 * 
 * Track visited states: A Set is used to avoid revisiting configurations, ensuring efficiency.
 * 
 * Stop when the target is reached: If the target configuration is found during BFS, the number of moves (level) 
 * is returned.
 * 
 * Return -1 if unsolvable: If the BFS completes without finding the target, the puzzle is deemed unsolvable.
 * 
 * This approach ensures that all possible states are explored in the shortest path order, making it both optimal and efficient.
 */

class Solution {
    public int slidingPuzzle(int[][] board) {
        // As we've to find minMoves (level) so we'll make use of BFS

        // Step 1: Convert the input board into string & target also
        StringBuilder input = new StringBuilder();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                input.append(board[i][j]);
            }
        }

        String target = "123450";

        // Step 2: Store the position idx with which 0 idx can swap its position with in HashMap
        // HashMap<Integer, List<Integer>> mp = new HashMap<>();
        // mp.put(0, new ArrayList<>(Arrays.asList(1, 3)));
        // mp.put(1, new ArrayList<>(Arrays.asList(0, 4, 2)));
        // mp.put(2, new ArrayList<>(Arrays.asList(1, 5)));
        // mp.put(3, new ArrayList<>(Arrays.asList(0, 4)));
        // mp.put(4, new ArrayList<>(Arrays.asList(3, 1, 5)));
        // mp.put(5, new ArrayList<>(Arrays.asList(4, 2)));

        HashMap<Integer, int[]> mp = new HashMap<>();
        mp.put(0, new int[]{1, 3});
        mp.put(1, new int[]{0, 4, 2});
        mp.put(2, new int[]{1, 5});
        mp.put(3, new int[]{0, 4});
        mp.put(4, new int[]{3, 1, 5});
        mp.put(5, new int[]{4, 2});

        // Step 3: Use visited set to keep on checking whether swap is not already been done
        HashSet<String> visitedSet = new HashSet<>();
        visitedSet.add(input.toString());

        Queue<String> q = new LinkedList<>();
        q.offer(input.toString());

        int levels = 0;

        while(!q.isEmpty()) {
            int n = q.size();

            while(n-- > 0) {
                String current = q.poll();

                if(target.equals(current)) {
                    return levels;
                }

                int zeroIdx = current.indexOf('0');

                for(int adjacentIdx: mp.get(zeroIdx)) {
                    char[] chars = current.toCharArray();
                    
                    chars[zeroIdx] = chars[adjacentIdx];
                    chars[adjacentIdx] = '0';

                    String newState = new String(chars);

                    if(!visitedSet.contains(newState)) {
                        // marking as visited
                        visitedSet.add(newState);
                        // adding in the queue
                        q.offer(newState);
                    }
                }
            }

            levels++;
        }

        return -1;
    }
}